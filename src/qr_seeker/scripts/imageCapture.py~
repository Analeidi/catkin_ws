#!/usr/bin/env python

import FieldBehaviors
import PotentialFieldBrain
import FixedActions
import TurtleBot
import MultiCamShift as MCS
import cv2
from datetime import datetime
from collections import deque
import OlinGraph
from cv_bridge import CvBridge, CvBridgeError
import rospy
import time

import threading


from geometry_msgs.msg import Twist


class UpdateCamera( threading.Thread ):

	def __init__(self, bot, mcs):
		threading.Thread.__init__(self)
		self.lock = threading.Lock()
		self.runFlag = True
		self.robot = bot
		self.stalled = False
		self.frameAverageStallThreshold = 20

	def run(self):
		time.sleep(.5)
		runFlag = True
		cv2.namedWindow("TurtleCam", 1)
		timesImageServed = 1
		while(runFlag):

			image, timesImageServed = self.robot.getImage()

			with self.lock:
				if timesImageServed > 20:
					if self.stalled == False:
						print "Camera Stalled!"
					self.stalled = True
				else:
					self.stalled = False
			
			cv2.imshow("TurtleCam", image)

			code = chr(cv2.waitKey(50) & 255)

			if code == 't':
				cv2.imwrite("/home/macalester/catkin_ws/src/speedy_nav/res/captures/cap-" 
					+ time.strftime("%b%d%a-%H%M%S.jpg"), image)
				print "Image saved!"
			if code == 'q':
				break

			with self.lock:
				runFlag = self.runFlag

	def isStalled(self):
		"""Returns the status of the camera stream"""
		with self.lock:
			stalled = self.stalled
		return stalled

	def haltRun(self):
		with self.lock:
			self.runFlag = False




class Planner(object):

	def __init__(self):
		self.robot = TurtleBot.TurtleBot()
		self.brain = self.setupPot()

		image, times = self.robot.getImage()		
		self.mcs = MCS.MultiCamShift(image.shape)
		self.colorSearching = True

		self.camera = UpdateCamera(self.robot)

	def run(self,runtime = 120):
		"""Runs the pattern location program for the duration of 'runtime'"""
		timeout = time.time()+runtime
		self.camera.start()
		timeToWaitAfterStall = 30
		# iterators
		iterationCount = 0
		ignoreColorTime = 0
		sweepTime = 0
		sinceLastStall = 0
                print "Planner.run starting while loop"
		while time.time() < timeout and not rospy.is_shutdown():	

		self.camera.haltRun()
		self.camera.join()

	def exit(self):
		self.camera.haltRun()
	
if __name__=="__main__":
	rospy.init_node('Planner')
	plan = Planner()
	plan.run(5000)
	rospy.on_shutdown(plan.exit)
	rospy.spin()

