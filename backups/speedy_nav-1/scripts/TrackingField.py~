#!/usr/bin/env python

import rospy

import PotentialFieldBrain
import turtlebot
import MultiCamShift as MCS

import cv2
import numpy
import time
from datetime import datetime

import math
import random


class ObstacleForce(PotentialFieldBrain.PotentialFieldBehavior):

	def __init__(self, posPercent, speedMult):
		# posPercent is distance from left side of camera image, in percent of width (from 0 to 1)
		self.speedMult = speedMult
		self.imageWidth = 30
		self.angle = (posPercent-0.5)*60
		self.imageLeft = (640*posPercent)-(self.imageWidth/2)
		self.imageRight = self.imageLeft+self.imageWidth
		if self.imageRight > 640:
			self.imageLeft -= self.imageRight-640
			self.imageRight = 640
		elif self.imageLeft < 0:test_movement.TurtleBot()
			self.imageRight += 0-self.imageLeft
			self.imageLeft = 0
			
	def update(self):
		# width = 640
		# height = 480

		obstVals = self.robot.getDepth(self.imageLeft,
									   240-(self.imageWidth/2),
									   self.imageWidth,
									   self.imageWidth)

		masked_obstVals = numpy.ma.masked_array(obstVals, obstVals==0)
		# print numpy.ma.masked_array(obstVals, obstVals==0)

		meanDistance = numpy.mean(masked_obstVals)
		
		#print "--------"
		#print masked_obstVals
		#print meanDistance
		#print (50/meanDistance, 180-(self.angle))

		if meanDistance < 1500:
			if meanDistance < 500:
				meanDistance = 500
			self.setVector(self.speedMult/meanDistance, 180-(self.angle))
			#self.setVector(0.0, 0.0)
			# print self.angle
		else:
			self.setVector(0.0, 0.0)


class KeepMoving(PotentialFieldBrain.PotentialFieldBehavior):
	"""This is a brain-dead class that just reports a fixed magnitude and a heading that
	matches the robot's current heading"""

	def update(self):
		"""set zero magnitude and current heading"""
		self.setVector(0.2, 0.0)

	


# -----------------------------------------------------
# Run the demo using something like this:

def runDemo(runtime = 120):
	brain = setupPot()
	image = brain.myRobot.getImage()

	mcs = MCS.MultiCamShift(image)

	brain.add( KeepMoving() )

	timeout = time.time()+runtime
	while time.time() < timeout and not rospy.is_shutdown():
		#rospy.sleep(0.1)
		print("======================================")
		brain.step()

	brain.stopAll()


					
def setupPot(robotCode = None):
	"""Helpful function takes optional robot code (the six-digit Fluke board number). If code
	is given, then this connects to the robot. Otherwise, it connects to a simulated robot, and
	then creates a SubsumptionBrain object and returns it."""

	currRobot = turtlebot.TurtleBot()
	currBrain = PotentialFieldBrain.PotentialFieldBrain(currRobot)
	return currBrain

if __name__=="__main__":
  rospy.init_node('TrackingField')
  runDemo(5000)

